<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Fortune.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tira</a> &gt; <a href="index.source.html" class="el_package">app.fortune</a> &gt; <span class="el_source">Fortune.java</span></div><h1>Fortune.java</h1><pre class="source lang-java linenums">package app.fortune;

import app.vector.*;
import app.pq.*;
import app.tree.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Comparator;

/**
 * Site events are sorted top to bottom, left to right.
 * If two events have an equal point, if only one of them is a site event, the site event is sorted
 * first because it will cancel any circle events at that location.
 */
<span class="fc" id="L15">class QueueCompare implements Comparator&lt;Event&gt;</span>
{
	@Override
	public int compare(Event a, Event b)
	{
<span class="fc" id="L20">		int result = Double.compare(b.point().y, a.point().y);</span>
<span class="fc bfc" id="L21" title="All 2 branches covered.">		if (result == 0)</span>
		{
<span class="fc" id="L23">			result = Double.compare(a.point().x, b.point().x);</span>
<span class="fc bfc" id="L24" title="All 2 branches covered.">			if (result == 0)</span>
			{
<span class="pc bpc" id="L26" title="3 of 4 branches missed.">				if (a.isSiteEvent() &amp;&amp; !b.isSiteEvent())</span>
<span class="nc" id="L27">					result = -1;</span>

<span class="pc bpc" id="L29" title="2 of 4 branches missed.">				if (!a.isSiteEvent() &amp;&amp; b.isSiteEvent())</span>
<span class="nc" id="L30">					result = 1;</span>
			}
<span class="fc" id="L32">			return result;</span>
		}
<span class="fc" id="L34">		return result;</span>
	}
}

public class Fortune
{
<span class="fc" id="L40">	Vector eventPoint = new Vector(0, 0);</span>
<span class="fc" id="L41">	public PriorityQueue&lt;Event&gt; queue = new PriorityQueue&lt;&gt;(new QueueCompare());</span>
<span class="fc" id="L42">	public Tree&lt;Arc&gt; beach = null;</span>
<span class="fc" id="L43">	ArrayList&lt;Edge&gt; edges = new ArrayList&lt;&gt;();</span>

	public class Result
	{
		/**
		 * List of line segments equaling the closed edges of the voronoi diagram.
		 */
		public List&lt;Edge&gt; edges;

		/**
		 * List of rays extending to infinity from origin Edge.a in the direction of Edge.b.
		 */
		public List&lt;Edge&gt; rays;

		Result(List&lt;Edge&gt; edges, List&lt;Edge&gt; rays)
<span class="fc" id="L58">		{</span>
<span class="fc" id="L59">			this.edges = edges;</span>
<span class="fc" id="L60">			this.rays = rays;</span>
<span class="fc" id="L61">		}</span>
	}

	public class Edge
	{
		public final Vector a;
		public final Vector b;

		public Edge(Vector a, Vector b)
<span class="fc" id="L70">		{</span>
<span class="fc" id="L71">			this.a = a;</span>
<span class="fc" id="L72">			this.b = b;</span>
<span class="fc" id="L73">		}</span>

		@Override
		public String toString()
		{
<span class="nc" id="L78">			return &quot;[ &quot; + a + &quot; -&gt; &quot; + b + &quot; ]&quot;;</span>
		}
	}

	/**
	 * @param sites List of seeds of the voronoi diagram.
	 */
	public Fortune(List&lt;Vector&gt; sites)
<span class="fc" id="L86">	{</span>
<span class="fc" id="L87">		sites.forEach(site -&gt; queue.push(new Event(site)));</span>
<span class="fc" id="L88">		checkInput();</span>
<span class="fc" id="L89">	}</span>

	/**
	 * @param sites Array of seeds of the voronoi diagram.
	 */
	public Fortune(Vector[] sites)
<span class="fc" id="L95">	{</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">		for (int i = 0; i &lt; sites.length; i++)</span>
<span class="fc" id="L97">			queue.push(new Event(sites[i]));</span>
<span class="fc" id="L98">		checkInput();</span>
<span class="fc" id="L99">	}</span>

	void checkInput()
	{
<span class="fc bfc" id="L103" title="All 2 branches covered.">		if (queue.size() &lt;= 1)</span>
<span class="fc" id="L104">			return;</span>
<span class="fc" id="L105">		Event e = queue.pop();</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">		if (Math.abs(queue.peek().point().y - e.point().y) &lt; Vector.PRECISION)</span>
<span class="nc" id="L107">			queue.push(new Event(new Vector(e.point().x, e.point().y + 4.0 * Vector.PRECISION)));</span>
		else
<span class="fc" id="L109">			queue.push(e);</span>
<span class="fc" id="L110">	}</span>

	void detectEvent(Tree&lt;Arc&gt;.Node node)
	{
<span class="fc" id="L114">		Arc arc = node.value();</span>
<span class="fc" id="L115">		Vector point = arc.circleEvent();</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">		if (point != null)</span>
<span class="fc" id="L117">			arc.event = queue.push(new Event(point, arc.site, node));</span>
<span class="fc" id="L118">	}</span>

	void removeEvent(Arc arc)
	{
<span class="pc bpc" id="L122" title="1 of 4 branches missed.">		if (arc != null &amp;&amp; arc.event != null)</span>
		{
<span class="fc" id="L124">			queue.delete(arc.event);</span>
<span class="fc" id="L125">			arc.event = null;</span>
		}
<span class="fc" id="L127">	}</span>

	Boundary[] generateBoundaries(Arc arc, Vector site)
	{
<span class="fc" id="L131">		Vector isect = Utils.parabolaPt(arc.site, site.y, site.x);</span>
<span class="fc" id="L132">		Ray left = new Ray(isect, Utils.bisector(arc.site, site));</span>
<span class="fc" id="L133">		Ray right = new Ray(isect, Utils.bisector(site, arc.site));</span>
<span class="fc" id="L134">		return new Boundary[] { new Boundary(left, arc.site, site), new Boundary(right, site, arc.site) };</span>
	}

	Boundary generateMergedBoundary(Arc left, Arc mid, Arc right, Vector origin)
	{
<span class="fc" id="L139">		Vector direction = mid.left.ray.direction</span>
<span class="fc" id="L140">			.add(mid.right.ray.direction)</span>
<span class="fc" id="L141">			.normalize();</span>

<span class="fc" id="L143">		Vector bisector = Utils.bisector(left.site, right.site);</span>

<span class="pc bpc" id="L145" title="1 of 2 branches missed.">		if (Vector.dot(direction, bisector) &lt; 0)</span>
<span class="nc" id="L146">			bisector = bisector.neg();</span>

<span class="fc" id="L148">		return new Boundary(</span>
			new Ray(origin, bisector),
			left.site,
			right.site
		);
	}

	Tree&lt;Arc&gt;.Node findArc(Vector point)
	{
<span class="fc" id="L157">		Tree&lt;Arc&gt;.Node result = null;</span>
<span class="fc" id="L158">		Tree&lt;Arc&gt;.Node current = beach.root();</span>

<span class="fc bfc" id="L160" title="All 2 branches covered.">		while (current != null)</span>
		{
<span class="fc" id="L162">			Vector end = current.value().left(point.y);</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">			if (point.x &lt; end.x)</span>
<span class="fc" id="L164">				current = current.left();</span>
			else
			{
<span class="fc" id="L167">				result = current;</span>
<span class="fc" id="L168">				current = current.right();</span>
			}
<span class="fc" id="L170">		}</span>

<span class="fc" id="L172">		return result;</span>
	}
	
	void siteEvent(Event event)
	{
<span class="fc" id="L177">		Vector site = event.site();</span>
<span class="fc bfc" id="L178" title="All 2 branches covered.">		if (beach == null)</span>
		{
<span class="fc" id="L180">			beach = new Tree(new Arc(null, site, null));</span>
<span class="fc" id="L181">			return;</span>
		}

		// find arc above the event point

		// Set the site x-coordinate at positive infinity in case the event point is at the
		// exact point of the left edge of the arc it's on.
<span class="fc" id="L188">		Tree&lt;Arc&gt;.Node node = findArc(site);</span>
<span class="fc" id="L189">		Arc arc = node.value();</span>

		// if the arc defines a circle event it's a false alarm. Remove event from qeueue
<span class="fc" id="L192">		removeEvent(arc);</span>

		// split the arc into new sections
<span class="fc" id="L195">		Boundary[] bounds = generateBoundaries(arc, site);</span>
<span class="fc" id="L196">		Boundary left = bounds[0];</span>
<span class="fc" id="L197">		Boundary right = bounds[1];</span>

<span class="fc" id="L199">		Arc leftArc = new Arc(arc.left, arc.site, left);</span>
<span class="fc" id="L200">		Arc rightArc = new Arc(right, arc.site, arc.right);</span>
<span class="fc" id="L201">		arc = new Arc(left, site, right);</span>

<span class="fc" id="L203">		node = beach.replace(node, arc);</span>
<span class="fc" id="L204">		detectEvent(beach.addPrevious(node, leftArc));</span>
<span class="fc" id="L205">		detectEvent(beach.addNext(node, rightArc));</span>
<span class="fc" id="L206">	}</span>

	void circleEvent(Event e)
	{
<span class="fc" id="L210">		Vector point = e.point();</span>
<span class="fc" id="L211">		Vector site = e.site();</span>
<span class="fc" id="L212">		Vector circlePoint = Utils.parabolaPt(site, sweepLine(), point.x);</span>

		// Find and remove the arc being removed and its adjacent arcs
		Tree&lt;Arc&gt;.Node lNode, node, rNode;

<span class="fc" id="L217">		node = e.arc;</span>
<span class="fc" id="L218">		lNode = node.previous();</span>
<span class="fc" id="L219">		rNode = node.next();</span>

<span class="fc" id="L221">		Arc arc = node.value();</span>
<span class="fc" id="L222">		Arc larc = lNode.value();</span>
<span class="fc" id="L223">		Arc rarc = rNode.value();</span>

<span class="fc" id="L225">		beach.delete(node);</span>
		// Remove all events involving the arc including any caused by its boundaries
<span class="fc" id="L227">		removeEvent(larc);</span>
<span class="fc" id="L228">		removeEvent(rarc);</span>

		// rebuild the left and right arcs surrounding the removed arc
<span class="fc" id="L231">		Boundary middle = generateMergedBoundary(larc, arc, rarc, circlePoint);</span>
<span class="fc" id="L232">		Arc left = new Arc(larc.left, larc.site, middle);</span>
<span class="fc" id="L233">		Arc right = new Arc(middle, rarc.site, rarc.right);</span>

<span class="fc" id="L235">		lNode = beach.replace(lNode, left);</span>
<span class="fc" id="L236">		rNode = beach.replace(rNode, right);</span>

<span class="fc" id="L238">		detectEvent(lNode);</span>
<span class="fc" id="L239">		detectEvent(rNode);</span>

		// add edges of removed arc to result
<span class="fc" id="L242">		edges.add(new Edge(arc.left.ray.origin, circlePoint));</span>
<span class="fc" id="L243">		edges.add(new Edge(arc.right.ray.origin, circlePoint));</span>
<span class="fc" id="L244">	}</span>

	/**
	 * Processes a single event point per call.
	 * @return true, if not all events have been processed.
	 */
	public boolean process()
	{
<span class="fc bfc" id="L252" title="All 2 branches covered.">		if (!queue.isEmpty())</span>
		{
<span class="fc" id="L254">			Event e = queue.pop();</span>
<span class="fc" id="L255">			eventPoint = e.point();</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">			if (e.isSiteEvent())</span>
<span class="fc" id="L257">				siteEvent(e);</span>
			else
<span class="fc" id="L259">				circleEvent(e);</span>
		}

<span class="fc bfc" id="L262" title="All 2 branches covered.">		return !queue.isEmpty();</span>
	}

	/**
	 * Processes all event points before the y coordinate.
	 */
	public Result processTo(double y)
	{
<span class="nc bnc" id="L270" title="All 2 branches missed.">		while (!queue.isEmpty())</span>
		{
<span class="nc bnc" id="L272" title="All 2 branches missed.">			if (queue.peek().point().y &lt; y)</span>
<span class="nc" id="L273">				break;</span>

<span class="nc" id="L275">			process();</span>
		}

<span class="nc" id="L278">		setSweepline(y);</span>
<span class="nc" id="L279">		return result();</span>
	}

	/**
	 * Immediately generates the voronoi diagram.
	 */
	public Result processAll()
	{
<span class="fc bfc" id="L287" title="All 2 branches covered.">		while (process());</span>
<span class="fc" id="L288">		return result();</span>
	}

	/**
	 * Returns the next event in the queue if any.
	 */
	public Vector peek()
	{
<span class="nc bnc" id="L296" title="All 2 branches missed.">		if (!queue.isEmpty())</span>
<span class="nc" id="L297">			return queue.peek().point();</span>
<span class="nc" id="L298">		return null;</span>
	}

	/**
	 * Returns the height of the sweep line
	 */
	public double sweepLine()
	{
<span class="fc" id="L306">		return eventPoint.y;</span>
	}

	/**
	 * For visualization purposes.
	 * Set the sweepline height for the algorithm if it is between the current height and the
	 * y-coordinate of the next event point.
	 */
	public void setSweepline(double y)
	{
<span class="nc bnc" id="L316" title="All 2 branches missed.">		if (queue.isEmpty() ||</span>
<span class="nc bnc" id="L317" title="All 4 branches missed.">			(y &lt; sweepLine() &amp;&amp; y &gt; queue.peek().point().y))</span>
<span class="nc" id="L318">			eventPoint = new Vector(sweepLine(), y);</span>
<span class="nc" id="L319">	}</span>

	/**
	 * Query the result of the algorithm.
	 * @return the current state of the generated diagram.
	 */
	public Result result()
	{
<span class="fc" id="L327">		ArrayList&lt;Edge&gt; resEdges = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">		for (Edge edge : edges)</span>
<span class="fc" id="L329">			resEdges.add(edge);</span>

<span class="fc" id="L331">		ArrayList&lt;Edge&gt; infEdges = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L333" title="All 2 branches covered.">		if (beach != null)</span>
<span class="fc" id="L334">			beach.forEach(is -&gt;</span>
			{
<span class="fc" id="L336">				Arc arc = (Arc) is;</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">				if (arc.left != null)</span>
<span class="fc" id="L338">					infEdges.add(new Edge(arc.left.ray.origin, arc.left.ray.direction));</span>
<span class="fc" id="L339">			});</span>

<span class="fc" id="L341">		return new Result(resEdges, infEdges);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>